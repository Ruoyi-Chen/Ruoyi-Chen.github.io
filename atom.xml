<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://ruoyi-chen.github.io</id>
    <title>Chen Ruoyi </title>
    <updated>2021-11-25T01:53:07.985Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://ruoyi-chen.github.io"/>
    <link rel="self" href="https://ruoyi-chen.github.io/atom.xml"/>
    <subtitle>Per Aspera Ad Astra | 循此苦旅，以达天际</subtitle>
    <logo>https://ruoyi-chen.github.io/images/avatar.png</logo>
    <icon>https://ruoyi-chen.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Chen Ruoyi </rights>
    <entry>
        <title type="html"><![CDATA[🖤 LeetCode｜链表题总结]]></title>
        <id>https://ruoyi-chen.github.io/post/orlian-biao-ti-zong-jie/</id>
        <link href="https://ruoyi-chen.github.io/post/orlian-biao-ti-zong-jie/">
        </link>
        <updated>2021-11-25T00:36:57.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>链表题一开始做有点晕，出现了改掉指针破坏了原链表但是还继续用的bug（比如：回文链表识别，原来的想法是先反转，再一个一个比较，但是忘记了反转完链表就变了呀，这个时候head就是尾巴了，没有next；除非再新建一个链表，把原始列表复制过去，空间复杂度O(n)）。<br>
有一些很巧妙的做法，最常用的是快慢指针和递归。<br>
<ul class="markdownIt-TOC">
<li><a href="#1-%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C%E6%96%B0%E5%A2%9E%E5%88%A0%E9%99%A4">1 简单操作：新增，删除</a></li>
<li><a href="#2-%E5%89%8D%E5%90%8E%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88">2 前后/前中后/快慢指针</a>
<ul>
<li><a href="#21-%E5%89%8D%E5%90%8E%E6%8C%87%E9%92%88%E5%88%A0%E9%99%A4%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E8%8A%82%E7%82%B9">2.1 前后指针：删除倒数第N个节点</a></li>
<li><a href="#22-%E5%89%8D%E4%B8%AD%E5%90%8E%E6%8C%87%E9%92%88%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8">2.2 前中后指针：反转链表</a></li>
<li><a href="#23-%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8">2.3 快慢指针：回文链表</a></li>
<li><a href="#24-%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8">2.4 快慢指针：环形链表</a></li>
</ul>
</li>
<li><a href="#3-%E9%80%92%E5%BD%92">3 递归</a>
<ul>
<li><a href="#%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8">反转链表</a></li>
</ul>
</li>
</ul>
</p>
</blockquote>
<h1 id="1-简单操作新增删除">1 简单操作：新增，删除</h1>
<ul>
<li>新增：C插入A B -&gt; C的下一个指向B C.next = B -&gt; A的下一个指向C</li>
<li>删除：A B C D删掉B，直接把A的下一个指向C就可以了。但是！我们识别到B的时候就不能看到A了（因为单链表是A-&gt;B-&gt;C，不能反向读），所以，我们需要找个替身，把当前的B“伪装”成C（属性值赋为C的属性），然后B-&gt;D，相当于删掉了B，实际上是删掉了C地址上的那个node。<br>
都需要用一个while(A.next!=null){}走一遍，因为链表不像数组一样可以indexing。</li>
</ul>
<pre><code class="language-java">/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public void deleteNode(ListNode node) {
        node.val = node.next.val;
        node.next = node.next.next;
    }
}
</code></pre>
<h1 id="2-前后前中后快慢指针">2 前后/前中后/快慢指针</h1>
<blockquote>
<p>前后指针指的是一个走在前一个走在后，快慢指针指的是一个一次走一步，一个一次走两步（多步）。</p>
</blockquote>
<h2 id="21-前后指针删除倒数第n个节点">2.1 前后指针：删除倒数第N个节点</h2>
<p>怎么找到倒数第N个呢？--&gt;用快慢指针。<br>
<img src="https://ruoyi-chen.github.io/post-images/1637801820755.png" alt="" loading="lazy"><br>
要找到倒数第二个节点，那么快指针比慢指针先走两步，当快指针走到尾（null）时，慢指针就走到倒数第二个。</p>
<p>另外，在对链表进行操作时，一种常用的技巧是添加一个哑节点（dummy node），它的 next指针指向链表的头节点。这样一来，我们就不需要对头节点进行特殊的判断了。</p>
<figure data-type="image" tabindex="1"><img src="https://ruoyi-chen.github.io/post-images/1637802031837.png" alt="" loading="lazy"></figure>
<pre><code class="language-java">class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode dummy = new ListNode(0, head);
        ListNode first = head;
        ListNode second = dummy;
        for (int i = 0; i &lt; n; ++i) {
            first = first.next;
        }
        while (first != null) {
            first = first.next;
            second = second.next;
        }
        second.next = second.next.next;
        ListNode ans = dummy.next;
        return ans;
    }
}
</code></pre>
<h2 id="22-前中后指针反转链表">2.2 前中后指针：反转链表</h2>
<p>给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。<br>
提示：<br>
链表中节点的数目范围是 [0, 5000]<br>
-5000 &lt;= Node.val &lt;= 5000</p>
<p>链接：https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xnnhm6/</p>
<figure data-type="image" tabindex="2"><img src="https://ruoyi-chen.github.io/post-images/1637802324478.png" alt="" loading="lazy"></figure>
<p>A -&gt; B -&gt; C -&gt; D<br>
从B开始，先存储前一个节点C（不然的话，断开了指针就找不到C了），指针给到A，A &lt;- B -&gt; C -&gt; D。以此类推。</p>
<pre><code class="language-java">/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode prev = null;
        ListNode cur = head;

        while(cur != null){
            ListNode temp = cur.next;
            cur.next = prev;
            prev = cur;
            cur = temp;
        }
        return prev;

    }
}
</code></pre>
<h2 id="23-快慢指针回文链表">2.3 快慢指针：回文链表</h2>
<p>给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。<br>
提示：<br>
链表中节点数目在范围[1, 105] 内<br>
0 &lt;= Node.val &lt;= 9<br>
 <br>
进阶：你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？<br>
链接：https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xnv1oc/</p>
<figure data-type="image" tabindex="3"><img src="https://ruoyi-chen.github.io/post-images/1637803960554.png" alt="" loading="lazy"></figure>
<p>A -&gt; B -&gt; C -&gt; B -&gt; A<br>
思路：把链表变成A &lt;- B &lt;- C -&gt; B -&gt; A，从两边散开分别比较。<br>
关键点1：链表不能获得长度（除非遍历一遍），那怎么走到中间？-&gt; 用快慢指针，慢走一步快走两步，快走到null（或fast.next == null）时，慢就走到中间了。<br>
关键点2：怎么在空间复杂度O(1)解决这个问题？前半部分边走边反转，反转方法和2.2一样。不考虑空间复杂度，就直接复制到一个新的数组里了。</p>
<pre><code class="language-java">/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public boolean isPalindrome(ListNode head) {
        //快慢指针
        ListNode slow = head;
        ListNode fast = head;
        ListNode pre = head;
        ListNode prepre = null;

        //slow走到中间，边走边反转
        //       head&lt;-...pre&lt;-slow-&gt;......-&gt;fast
        while(fast != null &amp;&amp; fast.next != null){
            //slow和fast向前走
            slow = slow.next;
            fast = fast.next.next;
            //前反转
            pre.next = prepre;
            prepre = pre;
            pre = slow;
        }
        if(fast != null){
            slow = slow.next;
        }

        while(slow != null){
            if(slow.val != prepre.val){
                return false;
            }
            slow = slow.next;
            prepre = prepre.next;
        }
        return true;
    }
}
</code></pre>
<h2 id="24-快慢指针环形链表">2.4 快慢指针：环形链表</h2>
<blockquote>
<p>这道题的龟兔赛跑用的很巧妙。</p>
</blockquote>
<p>给你一个链表的头节点 head ，判断链表中是否有环。</p>
<p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p>
<p>如果链表中存在环，则返回 true 。 否则，返回 false 。<br>
链接：https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xnwzei/</p>
<figure data-type="image" tabindex="4"><img src="https://ruoyi-chen.github.io/post-images/1637804680116.png" alt="" loading="lazy"></figure>
<p>最直观的想法使用HashSet（和数组判断重复的一样，看能不能加到Set里，加不进去就说明有重复），时间复杂度和空间复杂度都是O(n)。</p>
<blockquote>
<p>摘自力扣题解<br>
本方法需要读者对「Floyd 判圈算法」（又称龟兔赛跑算法）有所了解。</p>
<p>假想「乌龟」和「兔子」在链表上移动，「兔子」跑得快，「乌龟」跑得慢。当「乌龟」和「兔子」从链表上的同一个节点开始移动时，如果该链表中没有环，那么「兔子」将一直处于「乌龟」的前方；如果该链表中有环，那么「兔子」会先于「乌龟」进入环，并且一直在环内移动。等到「乌龟」进入环时，由于「兔子」的速度快，它一定会在某个时刻与乌龟相遇，即套了「乌龟」若干圈。</p>
<p>我们可以根据上述思路来解决本题。具体地，我们定义两个指针，一快一满。慢指针每次只移动一步，而快指针每次移动两步。初始时，慢指针在位置 head，而快指针在位置 head.next。这样一来，如果在移动的过程中，快指针反过来追上慢指针，就说明该链表为环形链表。否则快指针将到达链表尾部，该链表不为环形链表。<br>
链接：https://leetcode-cn.com/problems/linked-list-cycle/solution/huan-xing-lian-biao-by-leetcode-solution/</p>
</blockquote>
<figure data-type="image" tabindex="5"><img src="https://ruoyi-chen.github.io/post-images/1637805051911.png" alt="" loading="lazy"></figure>
<p>🐰兔子跑两步，🐢乌龟跑一步，如果有环，兔子和乌龟肯定会相遇。</p>
<pre><code class="language-java">public class Solution {
    public boolean hasCycle(ListNode head) {
        if (head == null || head.next == null) {
            return false;
        }
        ListNode slow = head;
        ListNode fast = head.next;
        while (slow != fast) {
            if (fast == null || fast.next == null) {
                return false;
            }
            slow = slow.next;
            fast = fast.next.next;
        }
        return true;
    }
}
</code></pre>
<h1 id="3-递归">3 递归</h1>
<h2 id="反转链表">反转链表</h2>
<p>使用递归函数，一直递归到链表的最后一个结点，该结点就是反转后的头结点，记作 ret .<br>
此后，每次函数在返回的过程中，让当前结点的下一个结点的 next 指针指向当前节点。<br>
同时让当前结点的 next 指针指向 null（避免产生环，A-&gt;B-&gt;C-&gt;D  ===&gt; A-&gt;B**&lt;-&gt;<strong>C&lt;-D ，过不去了 就在BC之间转来转去了），从而实现从链表尾部开始的</strong>局部反转**<br>
当递归函数全部出栈后，链表反转完成。</p>
<blockquote>
<p>更好地理解递归：假设在中间开始。<br>
假设链表为：n_1-&gt;...-&gt;n_{k-1}-&gt;n_{k}-&gt;n_{k+1}-&gt;...-&gt;n_m-&gt;null<br>
若n_{k+1}-&gt;...-&gt;n_m-&gt;null已反转，我们处于nk。===&gt; 我们希望下一个是nk+1-&gt;nk，即nk.next.next = nk;<br>
需要注意的是nk的下一个节点必须指向 null。如果忽略了这一点，链表中可能会产生环。</p>
</blockquote>
<pre><code class="language-java">class Solution {
    public ListNode reverseList(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }
        ListNode newHead = reverseList(head.next);
        head.next.next = head;
        head.next = null;
        return newHead;
    }
}
</code></pre>
<p>链接：https://leetcode-cn.com/problems/reverse-linked-list/solution/fan-zhuan-lian-biao-by-leetcode-solution-d1k2/</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[💙 JDBC(3)｜ 使用PreparedStatement实现CRUD操作]]></title>
        <id>https://ruoyi-chen.github.io/post/jdbc3or-shi-yong-preparedstatement-shi-xian-crud-cao-zuo/</id>
        <link href="https://ruoyi-chen.github.io/post/jdbc3or-shi-yong-preparedstatement-shi-xian-crud-cao-zuo/">
        </link>
        <updated>2021-11-10T14:33:50.000Z</updated>
        <content type="html"><![CDATA[<h1 id="31-操作和访问数据库">3.1 操作和访问数据库</h1>
<p>数据库连接被用于向数据库服务器发送命令和 SQL 语句，并接受数据库服务器返回的结果。其实一个数据库连接就是一个<strong>Socket</strong>连接。<br>
在 java.sql 包中有 3 个接口分别定义了对数据库的调用的不同方式:</p>
<ul>
<li>Statement:用于执行<strong>静态 SQL 语句</strong>并返回它所生成结果的对象。</li>
<li>PrepatedStatement:SQL 语句被<strong>预编译</strong>并存储在此对象中，可以使用此对象多次高效地执行该语句。</li>
<li>CallableStatement:用于执行 SQL <strong>存储</strong>过程</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://ruoyi-chen.github.io/post-images/1636555005994.png" alt="" loading="lazy"></figure>
<h1 id="32">3.2</h1>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[🖤 LeetCode Daily｜初级算法(3)-原地旋转图像【medium】]]></title>
        <id>https://ruoyi-chen.github.io/post/leetcode-dailyorchu-ji-suan-fa-3-yuan-di-xuan-zhuan-tu-xiang-medium/</id>
        <link href="https://ruoyi-chen.github.io/post/leetcode-dailyorchu-ji-suan-fa-3-yuan-di-xuan-zhuan-tu-xiang-medium/">
        </link>
        <updated>2021-11-07T05:07:31.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。<br>
你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。</p>
</blockquote>
<figure data-type="image" tabindex="1"><img src="https://ruoyi-chen.github.io/post-images/1636261718587.png" alt="" loading="lazy"></figure>
<p>链接：<a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xnhhkv/">原题连接</a></p>
<h1 id="思路-1">思路 1</h1>
<figure data-type="image" tabindex="2"><img src="https://ruoyi-chen.github.io/post-images/1636261841044.png" alt="" loading="lazy"></figure>
<ol>
<li>先把每一行都翻转：对于每一行，头尾调换，直到中位数i=len/2</li>
<li>对角线对换：第一行和第四列的对换，第二行和第三列的对换。如图，第一行在（1，3）对换停止，第二行在（2，2）对换停止，也就是另一条对角线上的不用变。</li>
</ol>
<pre><code class="language-java">class Solution {
        public void rotate(int[][] matrix) {
        int len = matrix[0].length;

        // 每行翻转
        for (int i = 0; i &lt; len; i++) {
            for (int j = 0; j &lt; len/2; j++) {
                int temp = matrix[i][j];
                matrix[i][j] = matrix[i][len-1-j];
                matrix[i][len-1-j] = temp;
            }
        }

        // 对角线对换
        for (int i = 0; i &lt; len; i++) {
            int j = len-1-i;
            for (int u = 0; u &lt; len-i; u++) {
                int temp = matrix[i][u];
                matrix[i][u] = matrix[len-1-u][j];
                matrix[len-1-u][j] = temp;
            }

        }
    }
}
</code></pre>
<h1 id="总结">总结</h1>
<p>哇！完全靠自己想出来的最优解～超过100%，好开心！！❤️<br>
加油加油 不灰心不放弃 我行我会我可以！！</p>
<p>时间：2021/11/07</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[❤️ GRE总结]]></title>
        <id>https://ruoyi-chen.github.io/post/gre-zong-jie/</id>
        <link href="https://ruoyi-chen.github.io/post/gre-zong-jie/">
        </link>
        <updated>2021-11-06T14:43:40.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://ruoyi-chen.github.io/post-images/1636210273486.png" alt="" loading="lazy"><br>
<img src="https://ruoyi-chen.github.io/post-images/1636210282561.png" alt="" loading="lazy"><br>
<img src="https://ruoyi-chen.github.io/post-images/1636210289326.png" alt="" loading="lazy"><br>
<img src="https://ruoyi-chen.github.io/post-images/1636210297323.png" alt="" loading="lazy"><br>
<img src="https://ruoyi-chen.github.io/post-images/1636210306325.png" alt="" loading="lazy"><br>
<img src="https://ruoyi-chen.github.io/post-images/1636210316063.png" alt="" loading="lazy"><br>
<img src="https://ruoyi-chen.github.io/post-images/1636210325007.png" alt="" loading="lazy"><br>
<img src="https://ruoyi-chen.github.io/post-images/1636210337284.png" alt="" loading="lazy"><br>
<img src="https://ruoyi-chen.github.io/post-images/1636210352330.png" alt="" loading="lazy"><br>
<img src="https://ruoyi-chen.github.io/post-images/1636210362264.png" alt="" loading="lazy"><br>
<img src="https://ruoyi-chen.github.io/post-images/1636210373827.png" alt="" loading="lazy"><br>
<img src="https://ruoyi-chen.github.io/post-images/1636210379956.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[🖤 LeetCode Daily｜初级算法(2)-数独有效性验证【medium】]]></title>
        <id>https://ruoyi-chen.github.io/post/leetcode-dailyorchu-ji-suan-fa-2-shu-du-you-xiao-xing-yan-zheng-medium/</id>
        <link href="https://ruoyi-chen.github.io/post/leetcode-dailyorchu-ji-suan-fa-2-shu-du-you-xiao-xing-yan-zheng-medium/">
        </link>
        <updated>2021-11-06T11:47:07.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>请你判断一个 9x9 的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。<br>
数字 1-9 在每一行只能出现一次。<br>
数字 1-9 在每一列只能出现一次。<br>
数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）<br>
数独部分空格内已填入了数字，空白格用 '.' 表示。</p>
</blockquote>
<p>注意：<br>
一个有效的数独（部分已被填充）不一定是可解的。<br>
只需要根据以上规则，验证已经填入的数字是否有效即可。</p>
<p>链接：<a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2f9gg/">原题链接</a></p>
<p><ul class="markdownIt-TOC">
<li><a href="#%E6%9C%80%E6%9C%B4%E7%B4%A0%E7%9A%84%E6%83%B3%E6%B3%95%E8%BF%87%E4%BA%8E%E6%9A%B4%E5%8A%9B%E4%BA%86">最朴素的想法【过于暴力了】</a></li>
<li><a href="#%E4%BC%98%E5%8C%96%E5%90%8E">优化后</a></li>
<li><a href="#%E6%80%BB%E7%BB%93">总结</a></li>
</ul>
</p>
<h1 id="最朴素的想法过于暴力了">最朴素的想法【过于暴力了】</h1>
<p>输入的是二维数组，</p>
<ul>
<li>取出第一行，遍历a[1][i]; 取出第一列，如果不是&quot;.&quot;，将其添加进HashMap，如果已存在这个数，返回无效；</li>
<li>同理遍历a[j][1]。</li>
<li>遍历小格子，一共九个(3 x 3)，
<ul>
<li>第1个小格子(0, 0)包括a[0][0-2],a[1][0-2],a[2][0-2];</li>
<li>第二个小格子(0, 1) 包括a[0][0+3j, 1 + 3j, 2 + 3j],a[1][0+3j, 1 + 3j, 2 + 3j],a[2][0+3j, 1 + 3j, 2 + 3j]; ，j=1</li>
<li>以此类推，第（i，j）个格子包括a[0+3i, 1 + 3i, 2 + 3i][0+3j, 1 + 3j, 2 + 3j]，对每一个格子，进行一遍1-9出现一次判断。</li>
</ul>
</li>
<li>由于1-9出现一次判断在每一步都会出现，单独写成函数。<br>
行、列、小格子各遍历一次（复杂度很高、用了不合适的HashMap）：</li>
</ul>
<pre><code class="language-java">import org.junit.Test;

import java.util.HashMap;

public class SudokoTest {
        public boolean isValidSudoku(char[][] board) {

            char blank = '.';
            //行判断
            for(int i = 0; i &lt; 9; i++){
                HashMap map = new HashMap();
                for(int j = 0; j &lt; 9; j++){
                    System.out.print(board[i][j]);
                    if (board[i][j] != blank){
                        if (map.get(board[i][j]) != null){
                            return false;
                        }
                    }
                    map.put(board[i][j],1);
                }
            }
            System.out.println(&quot;Here1&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;);
            //列判断
            for(int i = 0; i &lt; 9; i++){
                HashMap map = new HashMap();
                for(int j = 0; j &lt; 9; j++){
                    System.out.print(board[j][i]);
                    if (board[j][i] != blank){
                        if (map.get(board[j][i]) != null){
                            return false;
                        }
                    }
                    map.put(board[j][i],1);
                }
            }

            System.out.println(&quot;Here2&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;);
            //小格子判断

            for(int u = 0; u &lt; 3; u++){
                for (int v = 0; v &lt; 3; v++) {
                    //第u，v个格子
                    HashMap map3 = new HashMap();

                    for(int i = 0+3*u; i &lt; 3+3*u; i++){
                        for(int j = 0+3*v; j &lt; 3+3*v; j++){
                            if (board[i][j] != blank){
                                if (map3.get(board[i][j]) != null){
                                    return false;
                                }
                                    map3.put(board[i][j],1);
                            }

                        }
                    }
                    System.out.println(&quot;Another&lt;&lt;&lt;&quot;);
                }
                System.out.println(&quot;next line&lt;&lt;&lt;&quot;);
            }

            System.out.println(&quot;Here&quot;);
            return true;
        }

        @Test
        public void test(){
            char[][] testChar = new char[][]{{'5', '3', '7', '.', '.', '.', '.', '.', '.'},
                    {'1', '.', '.', '.', '.', '.', '.', '.', '.'},
                    {'.', '9', '8', '.', '.', '.', '.', '.', '.'},
                    {'.', '.', '.', '.', '.', '.', '.', '.', '.'},
                    {'.', '.', '.', '.', '.', '.', '.', '.', '.'},
                    {'.', '.', '.', '.', '.', '.', '.', '.', '.'},
                    {'.', '.', '.', '.', '.', '.', '1', '.', '.'},
                    {'.', '.', '.', '.', '.', '.', '.', '.', '.'},
                    {'.', '.', '.', '.', '.', '.', '.', '9', '4'}};

            System.out.println(isValidSudoku(testChar));
        }
    }
</code></pre>
<h1 id="优化后">优化后</h1>
<p>显然这种方法的时间复杂度和空间复杂度都很高，因为每次都要new一个HashMap，要分三次update，不可取。<br>
首先考虑遍历一次记录下三个目标的方法：<br>
建立三个数组：</p>
<ul>
<li>row[i][num]:表示i行的num的数量</li>
<li>col[j][num]:表示j行的num的数量</li>
<li>box[j/3 + i/3*3]：表示第j/3 + i/3*3个小格子中的num的数量</li>
</ul>
<blockquote>
<p>WHY j/3 + i/3 * 3？<br>
j/3表示第j/3分列的格子<br>
i/3表示第i/3分行的格子<br>
满3个要往下移三行，故*3</p>
</blockquote>
<pre><code class="language-java">class Solution {
    public boolean isValidSudoku(char[][] board) {
            int[][] row = new int[9][10];
            int[][] col = new int[9][10];
            int[][] box = new int[9][10];

            for(int i = 0; i &lt; 9; i++){
                for(int j = 0; j &lt; 9; j++){
                    if(board[i][j] == '.'){
                        continue;
                    }

                    int num = board[i][j] - '1';

                    if(row[i][num] == 1){
                        return false;
                    }

                    if(col[j][num] == 1){
                        return false;
                    }
                    
                    if(box[j/3 + i/3 * 3][num] == 1){
                        return false;
                    }
                    row[i][num] = 1;
                    col[j][num] = 1;
                    box[j/3 + i/3 * 3][num] = 1;
                }
            }
            return true;
    }
}
</code></pre>
<hr>
<h1 id="总结">总结</h1>
<ul>
<li>难点在于如何判断是第几个分块：j/3 + i/3 * 下移的行数。</li>
<li>数字少且确定时用数组就可以了，不用HashMap。本题中由两个值确定key的情况，不适合用HashMap。</li>
<li>选择数据结构的时候不要被限制住了。</li>
</ul>
<p>时间：2021/11/06</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[🧡 Java练习 ｜练习TreeMap的Comparator、Comparable接口]]></title>
        <id>https://ruoyi-chen.github.io/post/java-lian-xi-orlian-xi-treemap-de-comparatorcomparable-jie-kou/</id>
        <link href="https://ruoyi-chen.github.io/post/java-lian-xi-orlian-xi-treemap-de-comparatorcomparable-jie-kou/">
        </link>
        <updated>2021-11-05T18:22:19.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>有8个显示器，其属性有尺寸和价格。编写一个Java应用程序，使用TreeMap&lt;K,V&gt;，按照价格从大到小排序输出所有显示器的信息，要求通过两种方式实现：通过实现Comparator接口和通过实现Comparable接口。</p>
</blockquote>
<h1 id="程序分析">程序分析</h1>
<h2 id="treemap特性">TreeMap特性</h2>
<ol>
<li>TreeMap存储Key-Value 对时，需要根据key-value对进行排序。TreeMap可以保证所有的Key-Value 对处于有序状态。</li>
<li>TreeSet底层使用红黑树结构存储数据</li>
</ol>
<h2 id="treemap的key的排序">TreeMap的Key的排序：</h2>
<ul>
<li>自然排序：TreeMap的所有的Key 必须实现Comparable接口，而且所有的Key应该是同一个类的对象，否则将会抛出ClasssCastException</li>
<li>定制排序：创建TreeMap时，传入一个Comparator 对象，该对象负责对TreeMap中的所有key 进行排序。此时不需要Map 的Key实现Comparable 接口</li>
<li>TreeMap判断两个key相等的标准：两个key通过compareTo()方法或者compare()方法返回0。</li>
</ul>
<h1 id="方法1screen实现comparable接口">方法1，Screen实现Comparable接口</h1>
<ol>
<li>Screen先声明fields，包括private类型的size、price，定义constructor、setter、getting、重写toString()</li>
<li>实现Comparable接口，重写compareTo()方法。</li>
</ol>
<ul>
<li>判断传入的对象是否是Screen的一个实例，如果是：</li>
<li>取出实例中的price进行比较，大于为-1，小于为1，相等为0</li>
<li>否则，抛出异常：数据类型不一致。</li>
</ul>
<pre><code class="language-java">import java.util.Scanner;

public class Screen implements Comparable{
   private int size;
   private double price;

   public Screen(int size, double price) {
       this.size = size;
       this.price = price;
   }

   public int getSize() {
       return size;
   }

   public void setSize(int size) {
       this.size = size;
   }

   public double getPrice() {
       return price;
   }

   public void setPrice(double price) {
       this.price = price;
   }

   @Override
   public String toString() {
       return &quot;Screen{&quot; +
               &quot; size='&quot; + size + '\'' +
               &quot;, price=&quot; + price +
               '}';
   }

   @Override
   public int compareTo(Object o) {
       if(o instanceof Screen){
           Screen screen = (Screen) o;
           if(this.price &gt; screen.price){
               return -1;
           }else if (this.price &lt; screen.price){
               return 1;
           }else return 0;
       }
       throw new RuntimeException(&quot;传入的数据类型不一致！&quot;);
   }
}
</code></pre>
<ul>
<li>测试</li>
</ul>
<ol>
<li>实例化一个TreeMap inventory和八个screen</li>
<li>将 screen放入inventory</li>
<li>调用treemap中的entrySet，赋给Set entrySet，接着调用entrySet的interator进行迭代。</li>
<li>在iterator中，将iterator.next强制转换为Map.Entry，然后使用.getKey(), .getValue()方法输出key和value。</li>
</ol>
<pre><code class="language-java">    @Test
    public void testComparable(){
        TreeMap inventory= new TreeMap();

        Screen screen1 = new Screen(100,2111);
        Screen screen2 = new Screen(200,2112);
        Screen screen3 = new Screen(200,1113);
        Screen screen4 = new Screen(100,9141);
        Screen screen5 = new Screen(100,3151);
        Screen screen6 = new Screen(100,3611);
        Screen screen7 = new Screen(100,2711);
        Screen screen8 = new Screen(100,8111);

        inventory.put(screen1, screen1.getPrice());
        inventory.put(screen2, screen2.getPrice());
        inventory.put(screen3, screen3.getPrice());
        inventory.put(screen4, screen4.getPrice());
        inventory.put(screen5, screen5.getPrice());
        inventory.put(screen6, screen6.getPrice());
        inventory.put(screen7, screen7.getPrice());
        inventory.put(screen8, screen8.getPrice());

        Set entrySet = inventory.entrySet();
        Iterator iterator = entrySet.iterator();
        while (iterator.hasNext()){
            Object obj = iterator.next();
            Map.Entry entry = (Map.Entry) obj;
            System.out.println(entry.getKey()+&quot;---&gt;&quot;+entry.getValue());
        }
    }
</code></pre>
<ul>
<li>结果</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://ruoyi-chen.github.io/post-images/1636136773556.png" alt="" loading="lazy"></figure>
<h1 id="方法2treemap实现comparator">方法2，TreeMap实现Comparator</h1>
<ol>
<li>
<p>Screen2的基本设置和Screen相同，但是不实现Comparable接口</p>
</li>
<li>
<p>在创建inventory时，写入comparator<br>
在TreeMap中new Comparator，重写其中的 compare()方法。</p>
</li>
</ol>
<ul>
<li>首先判断传入的o1，o2是否为Screen2的实例</li>
<li>如果是，将其转型为Screen2</li>
<li>然后调用Double.compare方法，比较两者的price</li>
<li>否则，抛出异常：数据类型不一致。</li>
</ul>
<pre><code class="language-java">    @Test
    public void testComparator(){
        TreeMap inventory= new TreeMap(new Comparator() {
            @Override
            public int compare(Object o1, Object o2) {
                if (o1 instanceof Screen2 &amp;&amp; o2 instanceof Screen2){
                    Screen2 screen1 = (Screen2) o1;
                    Screen2 screen2 = (Screen2) o2;

                    return -Double.compare(screen1.getPrice(), screen2.getPrice());
                }
                throw new RuntimeException(&quot;输入的类型不匹配！&quot;);
            }
        });
        Screen2 screen1 = new Screen2(100,6111);
        Screen2 screen2 = new Screen2(200,2112);
        Screen2 screen3 = new Screen2(240,1113);
        Screen2 screen4 = new Screen2(150,9141);
        Screen2 screen5 = new Screen2(120,3151);
        Screen2 screen6 = new Screen2(110,3611);
        Screen2 screen7 = new Screen2(400,2711);
        Screen2 screen8 = new Screen2(600,8111);

        inventory.put(screen1, screen1.getPrice());
        inventory.put(screen2, screen2.getPrice());
        inventory.put(screen3, screen3.getPrice());
        inventory.put(screen4, screen4.getPrice());
        inventory.put(screen5, screen5.getPrice());
        inventory.put(screen6, screen6.getPrice());
        inventory.put(screen7, screen7.getPrice());
        inventory.put(screen8, screen8.getPrice());

        Set entrySet = inventory.entrySet();
        Iterator iterator = entrySet.iterator();
        while (iterator.hasNext()){
            Object obj = iterator.next();
            Map.Entry entry = (Map.Entry) obj;
            System.out.println(entry.getKey()+&quot;---&gt;&quot;+entry.getValue());
        }
    }
</code></pre>
<ul>
<li>结果<br>
<img src="https://ruoyi-chen.github.io/post-images/1636182348217.png" alt="" loading="lazy"></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[🧡 Java练习 ｜ 添加社团成员并输出交集]]></title>
        <id>https://ruoyi-chen.github.io/post/java-lian-xi-or-tian-jia-she-tuan-cheng-yuan-bing-shu-chu-jiao-ji/</id>
        <link href="https://ruoyi-chen.github.io/post/java-lian-xi-or-tian-jia-she-tuan-cheng-yuan-bing-shu-chu-jiao-ji/">
        </link>
        <updated>2021-11-05T16:17:15.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>张三、李四等人是A社团成员，李四、王五等人是B社团成员，编写一个Java应用程序（要求使用集合类），输出参加A社团的人、参加B社团的人、以及同时参加两个社团的人。</p>
</blockquote>
<h1 id="程序分析">程序分析：</h1>
<ul>
<li>
<p>需要建立的类：社团类、学生类</p>
</li>
<li>
<p>学生Person类Field包括：学生姓名</p>
</li>
<li>
<p>社团Community类Field包括：社团名称、社团成员集合（ArrayList<Person>）</p>
</li>
<li>
<p>方法：<br>
<strong>1.	输出参加某社团的人</strong><br>
将成员加入社团，写一个add方法，加入private类型的社团对象；<br>
展示该社团中的成员，用iterator逐个输出community集合中的对象，注意重写Person中的toString()；</p>
</li>
</ul>
<p><strong>2.	输出同时参加两个社团的人</strong><br>
需要计算两个集合中的交集，对于一个集合，遍历其中的Person，和另一个集合逐个比较，将相同的加入intersection集合中。这里要比较两个Object（Person）对象，需要重写Person中的equals()。</p>
<h1 id="代码">代码</h1>
<ul>
<li>Person</li>
</ul>
<pre><code class="language-java">public class Person {
    private String name;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Person(String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return &quot;Person{&quot; +
                &quot;name='&quot; + name + '\'' +
                '}';
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Person person = (Person) o;
        return Objects.equals(name, person.name);
    }

    @Override
    public int hashCode() {
        return Objects.hash(name);
    }
}
</code></pre>
<ul>
<li>Community</li>
</ul>
<pre><code class="language-java">import java.util.ArrayList;
import java.util.Iterator;

public class Community {
    private String name;
    private ArrayList&lt;Person&gt; community = new ArrayList&lt;Person&gt;();

    public Community(String name) {
        this.name = name;
    }

    public ArrayList&lt;Person&gt; getCommunity() {
        return community;
    }

    public void add(Person person) {
        community.add(person);
    }

    public void show() {
        System.out.println(&quot;参加社团&quot;+name+&quot;的学生：&quot;);
        Iterator iterator = community.iterator();
        while (iterator.hasNext()) {
            System.out.println(iterator.next());
        }
    }

    public ArrayList&lt;Person&gt; intersect(Community another){
        ArrayList&lt;Person&gt; intersection = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; community.size(); i++){
            for (int j = 0; j &lt; another.getCommunity().size(); j++){
                if(community.get(i).equals(another.getCommunity().get(j))){
                       intersection.add(community.get(i));
                }
            }
        }
        return intersection;
    }

    public void showIntersection(Community another){
        System.out.println(&quot;参加这两个社团的学生：&quot;);
        ArrayList&lt;Person&gt; intersection = intersect(another);
        Iterator iterator = intersection.iterator();
        while (iterator.hasNext()){
            System.out.println(iterator.next());
        }
    }
}
</code></pre>
<ul>
<li>Test</li>
</ul>
<pre><code>public class CommunityTest {
    public static void main(String[] args) throws Exception {
        Community communityA = new Community(&quot;社团A&quot;);
        Community communityB = new Community(&quot;社团B&quot;);

        Person zhangSan = new Person(&quot;Zhang San&quot;);
        Person liSi = new Person(&quot;Li Si&quot;);
        Person wangWu = new Person(&quot;Wang Wu&quot;);

        communityA.add(zhangSan);
        communityA.add(liSi);
        communityB.add(liSi);
        communityB.add(wangWu);

        communityA.show();
        communityB.show();

        communityA.showIntersection(communityB);

    }
}
</code></pre>
<h1 id="结果">结果</h1>
<figure data-type="image" tabindex="1"><img src="https://ruoyi-chen.github.io/post-images/1636129797471.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[🖤 LeetCode Daily｜初级算法(1)-两数之和【easy】]]></title>
        <id>https://ruoyi-chen.github.io/post/leetcode-mei-ri-yi-ti-1-chu-ji-suan-fa-liang-shu-zhi-he-easy/</id>
        <link href="https://ruoyi-chen.github.io/post/leetcode-mei-ri-yi-ti-1-chu-ji-suan-fa-liang-shu-zhi-he-easy/">
        </link>
        <updated>2021-11-05T14:09:27.000Z</updated>
        <content type="html"><![CDATA[<h1 id="两数之和">两数之和</h1>
<blockquote>
<p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p>
<p>你可以按任意顺序返回答案。</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2jrse/">原题链接</a></p>
<ul>
<li>用HashMap或双指针做。</li>
<li>思路是：如果能找到与一个数相加得target的数，那就把这个数（key）的value返回，否则把这个数放入HashMap中。</li>
</ul>
<pre><code class="language-java">class Solution {
    public int[] twoSum(int[] nums, int target) {
        HashMap&lt;Integer, Integer&gt; map = new HashMap();
        for(int i = 0; i &lt; nums.length; i++){
            if(map.get(target - nums[i]) != null){
                return new int[]{map.get(target - nums[i]), i};
            }
            map.put(nums[i], i);
        }
        return new int[]{0,0};
    }
}
</code></pre>
<ul>
<li>
<p>Bug1：<br>
一开始想用二分查找来找（target - nums[i]），但是这就要求一开始要排序。<br>
题目要求输出的是索引位置，用这种思路的话就要新建一个数组放进去。而Java中将一个数组赋给另一个数组是引用形式赋过去的，所以原数组顺序变了新的数组顺序也会变。重新用一个for循环赋进去又很麻烦，要再一次找index，而且还要一次顺序找index一次逆序找index（比如[3,3]，6，要得到的是[0,1]，只用顺序查找的话就会输出[0,0]）</p>
</li>
<li>
<p>Bug2:<br>
小聪明想着那我从比target小的数开始找好了，可以少找一些。但没考虑到测试数组中存在[-3,1,4]这种情况，如果target==1，就会出错了，还是不可避免要全部遍历一次。</p>
</li>
</ul>
<hr>
<p>🎉“微习惯”养成记：Start From Little。就从每天至少一道LeetCode开始吧！<br>
（今天写了三道，但是这道比较有记录的意义啦～加油！）<br>
日期：2021/11/05</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[💙 JDBC(2)｜ SQL语句注入-Statement/PreparedStatement]]></title>
        <id>https://ruoyi-chen.github.io/post/jdbc2/</id>
        <link href="https://ruoyi-chen.github.io/post/jdbc2/">
        </link>
        <updated>2021-11-05T11:01:16.000Z</updated>
        <content type="html"><![CDATA[<h1 id="statement操作的弊端">Statement操作的弊端</h1>
<ul>
<li>需要拼写sql语句，并存在sql注入问题</li>
<li>sql注入问题：利用某些系统没有对用户输入的数据进行充分的检查，而在用户输入数据中注入非法的SQL语句段或命令，从而利用系统的SQL引擎完成恶意行为的做法（比如，SELECT user, password FROM user_table WHERE user = 'a' OR = 1 =' AND password = 'OR '1' = '1'）。</li>
<li>为了避免这一问题，我们需要用Prepared Statement（从Statement扩展而来）取代Statement</li>
</ul>
<pre><code class="language-java">public class StatementTest {
    //使用Statement的弊端：需要拼写sql语句，并存在sql注入的问题
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        System.out.println(&quot;username:&quot;);
        String user = scanner.next();
        System.out.println(&quot;password:&quot;);
        String password = scanner.next();

        String sql = &quot;SELECT user, password FROM user_table WHERE user = '&quot;+ user +&quot;' AND password = '&quot;+ password +&quot;'&quot;;
        User returnUser = get(sql, User.class);
        if(returnUser != null){
            System.out.println(&quot;登录成功&quot;);
        }
        else{
            System.out.println(&quot;用户名不存在或密码错误&quot;);
        }
    }

    // 使用Statement实现对数据表的查询操作
    public static &lt;T&gt; T get(String sql, Class&lt;T&gt; clazz) {
        T t = null;

        Connection conn = null;
        Statement st = null;
        ResultSet rs = null;
        try {
            // 1.加载配置文件
            InputStream is = StatementTest.class.getClassLoader().getResourceAsStream(&quot;jdbc.properties&quot;);
            Properties pros = new Properties();
            pros.load(is);

            // 2.读取配置信息
            String user = pros.getProperty(&quot;user&quot;);
            String password = pros.getProperty(&quot;password&quot;);
            String url = pros.getProperty(&quot;url&quot;);
            String driverClass = pros.getProperty(&quot;driverClass&quot;);

            // 3.加载驱动
            Class.forName(driverClass);

            // 4.获取连接
            conn = DriverManager.getConnection(url, user, password);

            st = conn.createStatement();

            rs = st.executeQuery(sql);

            // 获取结果集的元数据
            ResultSetMetaData rsmd = rs.getMetaData();

            // 获取结果集的列数
            int columnCount = rsmd.getColumnCount();

            if (rs.next()) {

                t = clazz.newInstance();

                for (int i = 0; i &lt; columnCount; i++) {
                    // //1. 获取列的名称
                    // String columnName = rsmd.getColumnName(i+1);

                    // 1. 获取列的别名
                    String columnName = rsmd.getColumnLabel(i + 1);

                    // 2. 根据列名获取对应数据表中的数据
                    Object columnVal = rs.getObject(columnName);

                    // 3. 将数据表中得到的数据，封装进对象
                    Field field = clazz.getDeclaredField(columnName);
                    field.setAccessible(true);
                    field.set(t, columnVal);
                }
                return t;
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            // 关闭资源
            if (rs != null) {
                try {
                    rs.close();
                } catch (SQLException e) {
                    e.printStackTrace();
                }
            }
            if (st != null) {
                try {
                    st.close();
                } catch (SQLException e) {
                    e.printStackTrace();
                }
            }

            if (conn != null) {
                try {
                    conn.close();
                } catch (SQLException e) {
                    e.printStackTrace();
                }
            }
        }

        return null;
    }

}
</code></pre>
<h1 id="使用preparedstatement">使用PreparedStatement</h1>
<p>步骤：</p>
<ul>
<li>读取url、user、password信息，准备连接</li>
<li>加载驱动</li>
<li>获取连接</li>
<li>预编译sql语句，返回PreparedStatement实例</li>
<li>填充占位符ps.setString()</li>
<li>执行操作：ps.execute()</li>
<li>关闭资源：ps和connection都要关闭。</li>
</ul>
<pre><code class="language-java">import org.junit.Test;

import java.io.IOException;
import java.io.InputStream;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Properties;

public class PreparedStatementUpdateTest {
    @Test
    public void testInsert() {
        Connection conn = null;
        PreparedStatement ps = null;

        try{

            //1. 读取配置文件中的四个基本信息
            InputStream is = ClassLoader.getSystemClassLoader().getResourceAsStream(&quot;jdbc.properties&quot;);
            Properties pros = new Properties();
            pros.load(is);

            String user = pros.getProperty(&quot;user&quot;);
            String password = pros.getProperty(&quot;password&quot;);
            String url = pros.getProperty(&quot;url&quot;);
            String driverClass = pros.getProperty(&quot;driverClass&quot;);

            //2, 加载驱动
            Class.forName(driverClass);

            //3. 获取连接
            conn = DriverManager.getConnection(url, user, password);

            //4，预编译sql语句，返回PreparedStatement的实例
            String sql = &quot;insert into customers(name, email, birth)values(?,?,?)&quot;;
            ps = conn.prepareStatement(sql);

            //5，填充占位符
            ps.setString(1,&quot;Cherrie&quot;);
            ps.setString(2,&quot;chenruoyisz@gmail.com&quot;);
            SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
            java.util.Date date = sdf.parse(&quot;2021-01-31&quot;);
            ps.setDate(3, (java.sql.Date) new Date(date.getTime()));

            //6, 执行操作
            ps.execute();
        }
        catch (Exception e){
            e.printStackTrace();
        }
        finally {
            //7, 资源关闭
            if(ps!=null) {
                try {
                    ps.close();
                } catch (SQLException e) {
                    e.printStackTrace();
                }
            }
          if(conn != null){
                try {
                    conn.close();
                } catch (SQLException e) {
                    e.printStackTrace();
                }
            }
        }

    }
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[💙 JDBC(1)｜获取数据库连接的五种方法]]></title>
        <id>https://ruoyi-chen.github.io/post/this-is-cherry/</id>
        <link href="https://ruoyi-chen.github.io/post/this-is-cherry/">
        </link>
        <updated>2021-11-04T08:45:59.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E7%9A%84%E4%BA%94%E7%A7%8D%E6%96%B9%E6%B3%95">获取数据库连接的五种方法</a>
<ul>
<li><a href="#%E6%96%B9%E6%B3%951-diver-%E6%9E%84%E9%80%A0connection%E6%94%BE%E5%85%A5url%E5%92%8Cinfo">方法1： Diver -&gt; 构造connection放入url和info</a></li>
<li><a href="#%E6%96%B9%E6%B3%952-%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%B0%84%E5%8A%A8%E6%80%81%E8%8E%B7%E5%8F%96driver%E7%B1%BB%E5%AF%B9%E8%B1%A1">方法2: 使用反射动态获取Driver类对象</a></li>
<li><a href="#%E6%96%B9%E6%B3%953-%E4%BD%BF%E7%94%A8drivermanager%E6%9B%BF%E6%8D%A2driver">方法3: 使用DriverManager替换Driver</a></li>
<li><a href="#%E6%96%B9%E6%B3%954-%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95%E4%B8%89%E5%8F%AF%E4%BB%A5%E5%8F%AA%E5%8A%A0%E8%BD%BD%E9%A9%B1%E5%8A%A8%E4%B8%8D%E7%94%A8%E6%98%BE%E7%A4%BA%E5%9C%B0%E6%B3%A8%E5%86%8C%E9%A9%B1%E5%8A%A8%E4%BA%86">方法4: 优化方法三：可以只加载驱动，不用显示地注册驱动了。</a></li>
<li><a href="#%E6%96%B9%E6%B3%955-final%E7%89%88%E6%9C%AC">方法5: final版本</a></li>
</ul>
</li>
</ul>
</p>
<h1 id="获取数据库连接的五种方法">获取数据库连接的五种方法</h1>
<p>Note: 以下方法为了看着简介都用了throws exception，最好用try-catch包一下。</p>
<h2 id="方法1-diver-构造connection放入url和info">方法1： Diver -&gt; 构造connection放入url和info</h2>
<pre><code>- url在Driver的源码里面可以找到：&quot;jdbc:mysql://localhost:3306/test&quot;
- setProperty：放入user和password
</code></pre>
<pre><code class="language-java">    @Test
    public void testConnection1() throws Exception {
        Driver driver = new com.mysql.cj.jdbc.Driver();

        //url: http://localhost:8080/gmall/keyboard.jpg
        //jdbc:mysql协议
        //localhost:ip地址
        //3306:默认mysql端口号
        //test：test数据库
        String url = &quot;jdbc:mysql://localhost:3306/test&quot;;
        //将用户名和密码封装在Properties中
        Properties info =new Properties();
        info.setProperty(&quot;user&quot;,&quot;root&quot;);
        info.setProperty(&quot;password&quot;,&quot;aaa123&quot;);

        Connection conn = driver.connect(url, info);

        System.out.println(conn);
    }
</code></pre>
<h2 id="方法2-使用反射动态获取driver类对象">方法2: 使用反射动态获取Driver类对象</h2>
<p>因为我们可能需要换成Oracle或其他的数据库，所以动态的去调Driver对象可以使代码更有可扩展性。</p>
<pre><code class="language-java">    public void testConnection2() throws Exception {
        //1. 获取Driver实现类对象，使用反射
        Class clazz = Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);
        Driver driver = (Driver) clazz.newInstance();

        //2.提供要链接的数据库
        String url = &quot;jdbc:mysql://localhost:3306/test&quot;;

        //3.提供链接需要的用户名和密码
        Properties info =new Properties();
        info.setProperty(&quot;user&quot;,&quot;root&quot;);
        info.setProperty(&quot;password&quot;,&quot;aaa123&quot;);

        //4.获取链接
        Connection conn = driver.connect(url, info);
        System.out.println(conn);
    }
</code></pre>
<h2 id="方法3-使用drivermanager替换driver">方法3: 使用DriverManager替换Driver</h2>
<pre><code class="language-java">    public void testConnection3() throws Exception {
        //1。获取Driver实现类对象
        Class clazz = Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);
        Driver driver = (Driver) clazz.newInstance();

        //2，提供另外三个链接的基本信息
        String url = &quot;jdbc:mysql://localhost:3306/test&quot;;
        String user = &quot;root&quot;;
        String password = &quot;aaa123&quot;;

        //注册驱动
        DriverManager.registerDriver(driver);

        //获取链接
        Connection conn = DriverManager.getConnection(url, user, password);
        System.out.println(conn);
    }
</code></pre>
<h2 id="方法4-优化方法三可以只加载驱动不用显示地注册驱动了">方法4: 优化方法三：可以只加载驱动，不用显示地注册驱动了。</h2>
<p>这是因为在载入时已经注册了。</p>
<pre><code class="language-java">    public void testConnection4() throws Exception {
        //1，提供另外三个链接的基本信息
        String url = &quot;jdbc:mysql://localhost:3306/test&quot;;
        String user = &quot;root&quot;;
        String password = &quot;aaa123&quot;;

        //2。获取Driver实现类对象
        Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);
        //这两步就不需要了：
//        Driver driver = (Driver) clazz.newInstance();
//        //注册驱动
//        DriverManager.registerDriver(driver);

        //获取链接
        Connection conn = DriverManager.getConnection(url, user, password);
        System.out.println(conn);
    }
}
</code></pre>
<h2 id="方法5-final版本">方法5: final版本</h2>
<p>配置信息最好不要以硬定义的方式写，最好写在配置文件中，然后加载进代码中。</p>
<ul>
<li>配置Properties<br>
注意：Properties里左右等号不要有空格<br>
新建一个File：jdbc.properties</li>
</ul>
<pre><code class="language-java">user=root
password=aaa123
url=jdbc:mysql://localhost::3306/test
driverClass=com.jdbc.cj.mysql.Driver
</code></pre>
<pre><code class="language-java">public void testConnection5() throws Exception {
        //1.读取配置文件中的4个基本信息
        InputStream is = ConnectionTest.class.getClassLoader().getResourceAsStream(&quot;jdbc.properties&quot;);

        Properties pros = new Properties();
        pros.load(is);

        String user = pros.getProperty(&quot;user&quot;);
        String password = pros.getProperty(&quot;password&quot;);
        String url = pros.getProperty(&quot;url&quot;);
        String driverClass = pros.getProperty(&quot;driverClass&quot;);

        //2.加载驱动
        Class.forName(driverClass);

        //3.获取连接
        Connection conn = DriverManager.getConnection(url, user, password);
        System.out.println(conn);
    }
</code></pre>
]]></content>
    </entry>
</feed>