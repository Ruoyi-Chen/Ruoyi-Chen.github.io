<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://ruoyi-chen.github.io</id>
    <title>Chen Ruoyi </title>
    <updated>2021-11-05T15:49:24.014Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://ruoyi-chen.github.io"/>
    <link rel="self" href="https://ruoyi-chen.github.io/atom.xml"/>
    <subtitle>Per Aspera Ad Astra | 循此苦旅，以达天际</subtitle>
    <logo>https://ruoyi-chen.github.io/images/avatar.png</logo>
    <icon>https://ruoyi-chen.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Chen Ruoyi </rights>
    <entry>
        <title type="html"><![CDATA[🖤 LeetCode Daily｜初级算法(1)-两数之和【easy】]]></title>
        <id>https://ruoyi-chen.github.io/post/leetcode-mei-ri-yi-ti-1-chu-ji-suan-fa-liang-shu-zhi-he-easy/</id>
        <link href="https://ruoyi-chen.github.io/post/leetcode-mei-ri-yi-ti-1-chu-ji-suan-fa-liang-shu-zhi-he-easy/">
        </link>
        <updated>2021-11-05T14:09:27.000Z</updated>
        <content type="html"><![CDATA[<h1 id="两数之和">两数之和</h1>
<blockquote>
<p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p>
<p>你可以按任意顺序返回答案。</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2jrse/">原题链接</a></p>
<ul>
<li>用HashMap或双指针做。</li>
<li>思路是：如果能找到与一个数相加得target的数，那就把这个数（key）的value返回，否则把这个数放入HashMap中。</li>
</ul>
<pre><code class="language-java">class Solution {
    public int[] twoSum(int[] nums, int target) {
        HashMap&lt;Integer, Integer&gt; map = new HashMap();
        for(int i = 0; i &lt; nums.length; i++){
            if(map.get(target - nums[i]) != null){
                return new int[]{map.get(target - nums[i]), i};
            }
            map.put(nums[i], i);
        }
        return new int[]{0,0};
    }
}
</code></pre>
<ul>
<li>
<p>Bug1：<br>
一开始想用二分查找来找（target - nums[i]），但是这就要求一开始要排序。<br>
题目要求输出的是索引位置，用这种思路的话就要新建一个数组放进去。而Java中将一个数组赋给另一个数组是引用形式赋过去的，所以原数组顺序变了新的数组顺序也会变。重新用一个for循环赋进去又很麻烦，要再一次找index，而且还要一次顺序找index一次逆序找index（比如[3,3]，6，要得到的是[0,1]，只用顺序查找的话就会输出[0,0]）</p>
</li>
<li>
<p>Bug2:<br>
小聪明想着那我从比target小的数开始找好了，可以少找一些。但没考虑到测试数组中存在[-3,1,4]这种情况，如果target==1，就会出错了，还是不可避免要全部遍历一次。</p>
</li>
</ul>
<hr>
<p>🎉“微习惯”养成记：Start From Little。就从每天至少一道LeetCode开始吧！<br>
（今天写了三道，但是这道比较有记录的意义啦～加油！）<br>
日期：2021/11/05</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[💙 JDBC(2)｜ SQL语句注入-Statement/PreparedStatement]]></title>
        <id>https://ruoyi-chen.github.io/post/jdbc2/</id>
        <link href="https://ruoyi-chen.github.io/post/jdbc2/">
        </link>
        <updated>2021-11-05T11:01:16.000Z</updated>
        <content type="html"><![CDATA[<h1 id="statement操作的弊端">Statement操作的弊端</h1>
<ul>
<li>需要拼写sql语句，并存在sql注入问题</li>
<li>sql注入问题：利用某些系统没有对用户输入的数据进行充分的检查，而在用户输入数据中注入非法的SQL语句段或命令，从而利用系统的SQL引擎完成恶意行为的做法（比如，SELECT user, password FROM user_table WHERE user = 'a' OR = 1 =' AND password = 'OR '1' = '1'）。</li>
<li>为了避免这一问题，我们需要用Prepared Statement（从Statement扩展而来）取代Statement</li>
</ul>
<pre><code class="language-java">public class StatementTest {
    //使用Statement的弊端：需要拼写sql语句，并存在sql注入的问题
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        System.out.println(&quot;username:&quot;);
        String user = scanner.next();
        System.out.println(&quot;password:&quot;);
        String password = scanner.next();

        String sql = &quot;SELECT user, password FROM user_table WHERE user = '&quot;+ user +&quot;' AND password = '&quot;+ password +&quot;'&quot;;
        User returnUser = get(sql, User.class);
        if(returnUser != null){
            System.out.println(&quot;登录成功&quot;);
        }
        else{
            System.out.println(&quot;用户名不存在或密码错误&quot;);
        }
    }

    // 使用Statement实现对数据表的查询操作
    public static &lt;T&gt; T get(String sql, Class&lt;T&gt; clazz) {
        T t = null;

        Connection conn = null;
        Statement st = null;
        ResultSet rs = null;
        try {
            // 1.加载配置文件
            InputStream is = StatementTest.class.getClassLoader().getResourceAsStream(&quot;jdbc.properties&quot;);
            Properties pros = new Properties();
            pros.load(is);

            // 2.读取配置信息
            String user = pros.getProperty(&quot;user&quot;);
            String password = pros.getProperty(&quot;password&quot;);
            String url = pros.getProperty(&quot;url&quot;);
            String driverClass = pros.getProperty(&quot;driverClass&quot;);

            // 3.加载驱动
            Class.forName(driverClass);

            // 4.获取连接
            conn = DriverManager.getConnection(url, user, password);

            st = conn.createStatement();

            rs = st.executeQuery(sql);

            // 获取结果集的元数据
            ResultSetMetaData rsmd = rs.getMetaData();

            // 获取结果集的列数
            int columnCount = rsmd.getColumnCount();

            if (rs.next()) {

                t = clazz.newInstance();

                for (int i = 0; i &lt; columnCount; i++) {
                    // //1. 获取列的名称
                    // String columnName = rsmd.getColumnName(i+1);

                    // 1. 获取列的别名
                    String columnName = rsmd.getColumnLabel(i + 1);

                    // 2. 根据列名获取对应数据表中的数据
                    Object columnVal = rs.getObject(columnName);

                    // 3. 将数据表中得到的数据，封装进对象
                    Field field = clazz.getDeclaredField(columnName);
                    field.setAccessible(true);
                    field.set(t, columnVal);
                }
                return t;
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            // 关闭资源
            if (rs != null) {
                try {
                    rs.close();
                } catch (SQLException e) {
                    e.printStackTrace();
                }
            }
            if (st != null) {
                try {
                    st.close();
                } catch (SQLException e) {
                    e.printStackTrace();
                }
            }

            if (conn != null) {
                try {
                    conn.close();
                } catch (SQLException e) {
                    e.printStackTrace();
                }
            }
        }

        return null;
    }

}
</code></pre>
<h1 id="使用preparedstatement">使用PreparedStatement</h1>
<p>步骤：</p>
<ul>
<li>读取url、user、password信息，准备连接</li>
<li>加载驱动</li>
<li>获取连接</li>
<li>预编译sql语句，返回PreparedStatement实例</li>
<li>填充占位符ps.setString()</li>
<li>执行操作：ps.execute()</li>
<li>关闭资源：ps和connection都要关闭。</li>
</ul>
<pre><code class="language-java">import org.junit.Test;

import java.io.IOException;
import java.io.InputStream;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Properties;

public class PreparedStatementUpdateTest {
    @Test
    public void testInsert() {
        Connection conn = null;
        PreparedStatement ps = null;

        try{

            //1. 读取配置文件中的四个基本信息
            InputStream is = ClassLoader.getSystemClassLoader().getResourceAsStream(&quot;jdbc.properties&quot;);
            Properties pros = new Properties();
            pros.load(is);

            String user = pros.getProperty(&quot;user&quot;);
            String password = pros.getProperty(&quot;password&quot;);
            String url = pros.getProperty(&quot;url&quot;);
            String driverClass = pros.getProperty(&quot;driverClass&quot;);

            //2, 加载驱动
            Class.forName(driverClass);

            //3. 获取连接
            conn = DriverManager.getConnection(url, user, password);

            //4，预编译sql语句，返回PreparedStatement的实例
            String sql = &quot;insert into customers(name, email, birth)values(?,?,?)&quot;;
            ps = conn.prepareStatement(sql);

            //5，填充占位符
            ps.setString(1,&quot;Cherrie&quot;);
            ps.setString(2,&quot;chenruoyisz@gmail.com&quot;);
            SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
            java.util.Date date = sdf.parse(&quot;2021-01-31&quot;);
            ps.setDate(3, (java.sql.Date) new Date(date.getTime()));

            //6, 执行操作
            ps.execute();
        }
        catch (Exception e){
            e.printStackTrace();
        }
        finally {
            //7, 资源关闭
            if(ps!=null) {
                try {
                    ps.close();
                } catch (SQLException e) {
                    e.printStackTrace();
                }
            }
          if(conn != null){
                try {
                    conn.close();
                } catch (SQLException e) {
                    e.printStackTrace();
                }
            }
        }

    }
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[💙 JDBC(1)｜获取数据库连接的五种方法]]></title>
        <id>https://ruoyi-chen.github.io/post/this-is-cherry/</id>
        <link href="https://ruoyi-chen.github.io/post/this-is-cherry/">
        </link>
        <updated>2021-11-04T08:45:59.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E7%9A%84%E4%BA%94%E7%A7%8D%E6%96%B9%E6%B3%95">获取数据库连接的五种方法</a>
<ul>
<li><a href="#%E6%96%B9%E6%B3%951-diver-%E6%9E%84%E9%80%A0connection%E6%94%BE%E5%85%A5url%E5%92%8Cinfo">方法1： Diver -&gt; 构造connection放入url和info</a></li>
<li><a href="#%E6%96%B9%E6%B3%952-%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%B0%84%E5%8A%A8%E6%80%81%E8%8E%B7%E5%8F%96driver%E7%B1%BB%E5%AF%B9%E8%B1%A1">方法2: 使用反射动态获取Driver类对象</a></li>
<li><a href="#%E6%96%B9%E6%B3%953-%E4%BD%BF%E7%94%A8drivermanager%E6%9B%BF%E6%8D%A2driver">方法3: 使用DriverManager替换Driver</a></li>
<li><a href="#%E6%96%B9%E6%B3%954-%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95%E4%B8%89%E5%8F%AF%E4%BB%A5%E5%8F%AA%E5%8A%A0%E8%BD%BD%E9%A9%B1%E5%8A%A8%E4%B8%8D%E7%94%A8%E6%98%BE%E7%A4%BA%E5%9C%B0%E6%B3%A8%E5%86%8C%E9%A9%B1%E5%8A%A8%E4%BA%86">方法4: 优化方法三：可以只加载驱动，不用显示地注册驱动了。</a></li>
<li><a href="#%E6%96%B9%E6%B3%955-final%E7%89%88%E6%9C%AC">方法5: final版本</a></li>
</ul>
</li>
</ul>
</p>
<h1 id="获取数据库连接的五种方法">获取数据库连接的五种方法</h1>
<p>Note: 以下方法为了看着简介都用了throws exception，最好用try-catch包一下。</p>
<h2 id="方法1-diver-构造connection放入url和info">方法1： Diver -&gt; 构造connection放入url和info</h2>
<pre><code>- url在Driver的源码里面可以找到：&quot;jdbc:mysql://localhost:3306/test&quot;
- setProperty：放入user和password
</code></pre>
<pre><code class="language-java">    @Test
    public void testConnection1() throws Exception {
        Driver driver = new com.mysql.cj.jdbc.Driver();

        //url: http://localhost:8080/gmall/keyboard.jpg
        //jdbc:mysql协议
        //localhost:ip地址
        //3306:默认mysql端口号
        //test：test数据库
        String url = &quot;jdbc:mysql://localhost:3306/test&quot;;
        //将用户名和密码封装在Properties中
        Properties info =new Properties();
        info.setProperty(&quot;user&quot;,&quot;root&quot;);
        info.setProperty(&quot;password&quot;,&quot;aaa123&quot;);

        Connection conn = driver.connect(url, info);

        System.out.println(conn);
    }
</code></pre>
<h2 id="方法2-使用反射动态获取driver类对象">方法2: 使用反射动态获取Driver类对象</h2>
<p>因为我们可能需要换成Oracle或其他的数据库，所以动态的去调Driver对象可以使代码更有可扩展性。</p>
<pre><code class="language-java">    public void testConnection2() throws Exception {
        //1. 获取Driver实现类对象，使用反射
        Class clazz = Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);
        Driver driver = (Driver) clazz.newInstance();

        //2.提供要链接的数据库
        String url = &quot;jdbc:mysql://localhost:3306/test&quot;;

        //3.提供链接需要的用户名和密码
        Properties info =new Properties();
        info.setProperty(&quot;user&quot;,&quot;root&quot;);
        info.setProperty(&quot;password&quot;,&quot;aaa123&quot;);

        //4.获取链接
        Connection conn = driver.connect(url, info);
        System.out.println(conn);
    }
</code></pre>
<h2 id="方法3-使用drivermanager替换driver">方法3: 使用DriverManager替换Driver</h2>
<pre><code class="language-java">    public void testConnection3() throws Exception {
        //1。获取Driver实现类对象
        Class clazz = Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);
        Driver driver = (Driver) clazz.newInstance();

        //2，提供另外三个链接的基本信息
        String url = &quot;jdbc:mysql://localhost:3306/test&quot;;
        String user = &quot;root&quot;;
        String password = &quot;aaa123&quot;;

        //注册驱动
        DriverManager.registerDriver(driver);

        //获取链接
        Connection conn = DriverManager.getConnection(url, user, password);
        System.out.println(conn);
    }
</code></pre>
<h2 id="方法4-优化方法三可以只加载驱动不用显示地注册驱动了">方法4: 优化方法三：可以只加载驱动，不用显示地注册驱动了。</h2>
<p>这是因为在载入时已经注册了。</p>
<pre><code class="language-java">    public void testConnection4() throws Exception {
        //1，提供另外三个链接的基本信息
        String url = &quot;jdbc:mysql://localhost:3306/test&quot;;
        String user = &quot;root&quot;;
        String password = &quot;aaa123&quot;;

        //2。获取Driver实现类对象
        Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);
        //这两步就不需要了：
//        Driver driver = (Driver) clazz.newInstance();
//        //注册驱动
//        DriverManager.registerDriver(driver);

        //获取链接
        Connection conn = DriverManager.getConnection(url, user, password);
        System.out.println(conn);
    }
}
</code></pre>
<h2 id="方法5-final版本">方法5: final版本</h2>
<p>配置信息最好不要以硬定义的方式写，最好写在配置文件中，然后加载进代码中。</p>
<ul>
<li>配置Properties<br>
注意：Properties里左右等号不要有空格<br>
新建一个File：jdbc.properties</li>
</ul>
<pre><code class="language-java">user=root
password=aaa123
url=jdbc:mysql://localhost::3306/test
driverClass=com.jdbc.cj.mysql.Driver
</code></pre>
<pre><code class="language-java">public void testConnection5() throws Exception {
        //1.读取配置文件中的4个基本信息
        InputStream is = ConnectionTest.class.getClassLoader().getResourceAsStream(&quot;jdbc.properties&quot;);

        Properties pros = new Properties();
        pros.load(is);

        String user = pros.getProperty(&quot;user&quot;);
        String password = pros.getProperty(&quot;password&quot;);
        String url = pros.getProperty(&quot;url&quot;);
        String driverClass = pros.getProperty(&quot;driverClass&quot;);

        //2.加载驱动
        Class.forName(driverClass);

        //3.获取连接
        Connection conn = DriverManager.getConnection(url, user, password);
        System.out.println(conn);
    }
</code></pre>
]]></content>
    </entry>
</feed>